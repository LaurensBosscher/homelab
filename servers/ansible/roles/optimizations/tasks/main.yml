---
- name: Gather facts (ensures memory facts are available)
  ansible.builtin.setup:
    filter: ansible_memtotal_mb
  tags: [optimizations]

- name: Set memory-related variables
  ansible.builtin.set_fact:
    total_mem_kb: "{{ ansible_memtotal_mb * 1024 | int }}"
    total_mem_gb: "{{ ansible_memtotal_mb // 1024 | int }}"
    k8s_low_mem_threshold_gb: 12
  tags: [optimizations]

- name: Calculate dynamic min_free_kbytes 512 MB
  ansible.builtin.set_fact:
    vm_min_free_kbytes: 524288
  tags: [optimizations]

- name: Set vm parameters for low-memory systems (< 12 GB)
  ansible.builtin.set_fact:
    vm_swappiness: "60"
    vm_dirty_ratio: "10"
    vm_dirty_background_ratio: "3"
    queue_depth: "32"
  when: total_mem_gb | int < k8s_low_mem_threshold_gb | int
  tags: [optimizations]

- name: Set vm parameters for normal/high-memory systems (>= 12 GB)
  ansible.builtin.set_fact:
    vm_swappiness: "60"
    vm_dirty_ratio: "15"
    vm_dirty_background_ratio: "5"
    queue_depth: "256"
  when: total_mem_gb | int >= k8s_low_mem_threshold_gb | int
  tags: [optimizations]

- name: Install tuned
  ansible.builtin.dnf:
    name: tuned
    state: present
  become: true
  tags: [optimizations]

- name: Enable and start tuned
  ansible.builtin.systemd:
    name: tuned
    enabled: true
    state: started
  become: true
  tags: [optimizations]

- name: Create directory for custom tuned profile
  ansible.builtin.file:
    path: /etc/tuned/profiles/kubernetes-node
    state: directory
    mode: "0755"
  become: true
  tags: [optimizations]

# Use a custom tuned profile instead of throughput-performance + manual overrides
- name: Create custom tuned profile for Kubernetes nodes
  ansible.builtin.copy:
    dest: /etc/tuned/profiles/kubernetes-node/tuned.conf
    mode: "0644"
    content: |
      [main]
      include=virtual-guest

      [sysctl]
      # With ZRAM, we can swap more aggressively (higher swappiness) to compress stale memory
      # and free up RAM for active workloads, as ZRAM latency is much lower than disk I/O.
      vm.swappiness = {{ vm_swappiness }}
      
      # Start writing dirty pages to disk earlier to avoid large I/O spikes
      vm.dirty_ratio = {{ vm_dirty_ratio }}
      vm.dirty_background_ratio = {{ vm_dirty_background_ratio }}
      
      # Prefer keeping directory structure in memory over file content for faster lookups
      vm.vfs_cache_pressure = 50
      
      # Reserve memory for atomic allocations to prevent network stack starvation
      vm.min_free_kbytes = {{ vm_min_free_kbytes }}
      
      # Write out dirty data more frequently to reduce data loss on crash
      vm.dirty_expire_centisecs = 3000
      vm.dirty_writeback_centisecs = 500
      
      # Trigger kswapd earlier to smooth out memory reclamation spikes
      vm.watermark_scale_factor = 200
      
      # Disable swap prefetching; ZRAM is CPU-bound not I/O-bound, so read-ahead is overhead
      vm.page-cluster = 0
      
      # Do not panic on OOM; let the OOM killer pick a process (usually a pod) to kill
      vm.panic_on_oom = 0
      
      # Allow overcommitting memory; K8s manages limits/requests, so OS should be lenient
      vm.overcommit_memory = 1
      
      # Reboot automatically 10 seconds after a kernel panic to recover the node
      kernel.panic = 10
      
      # Panic on oops to trigger the automatic reboot and recover from undefined states
      kernel.panic_on_oops = 1

      [vm]
      # Disable Transparent Huge Pages (THP) to prevent memory bloating and latency spikes in databases (Redis, etc.)
      transparent_hugepages = never
  become: true
  tags: [optimizations]
  register: tuned_profile_created

- name: Check active tuned profile
  ansible.builtin.command: tuned-adm active
  register: current_tuned_profile
  changed_when: false
  failed_when: false
  tags: [optimizations]

- name: Restart tuned to pick up new profile
  ansible.builtin.systemd:
    name: tuned
    state: restarted
  become: true
  when: >
    tuned_profile_created.changed or
    'Current active profile: kubernetes-node' not in current_tuned_profile.stdout
  tags: [optimizations]

- name: Activate kubernetes-node profile
  ansible.builtin.command: tuned-adm profile kubernetes-node
  become: true
  register: activation_result
  changed_when: "'Switched to profile' in activation_result.stdout"
  failed_when: activation_result.rc != 0
  when: "'Current active profile: kubernetes-node' not in current_tuned_profile.stdout"
  tags: [optimizations]

- name: Determine root block device name
  ansible.builtin.shell: |
    dev=$(findmnt -n -o SOURCE /)
    # Get the parent kernel name (e.g., vda1 -> vda). If no parent (e.g. vda), use the name itself.
    parent=$(lsblk -no pkname "$dev" | head -n1)
    if [ -z "$parent" ]; then
      echo "${dev#/dev/}"
    else
      echo "$parent"
    fi
  register: root_device_cmd
  changed_when: false
  failed_when: root_device_cmd.rc != 0 or (root_device_cmd.stdout | trim) == ""
  tags: [optimizations]

- name: Set root_block_device variable
  ansible.builtin.set_fact:
    root_block_device: "{{ root_device_cmd.stdout | trim }}"
  tags: [optimizations]

- name: Persist read_ahead_kb = 4096 and nr_requests via udev (recommended way)
  ansible.builtin.copy:
    dest: /etc/udev/rules.d/99-kubernetes-io.rules
    mode: "0644"
    content: |
      ACTION=="add|change", KERNEL=="{{ root_block_device }}", ATTR{queue/scheduler}="mq-deadline"
      ACTION=="add|change", KERNEL=="{{ root_block_device }}", ATTR{queue/read_ahead_kb}="4096"
      ACTION=="add|change", KERNEL=="{{ root_block_device }}", ATTR{queue/nr_requests}="{{ queue_depth }}"
    owner: root
  become: true
  register: udev_rules
  tags: [optimizations]

- name: Apply udev rules now (without reboot)
  ansible.builtin.command:
    argv: ["udevadm", "control", "--reload-rules"]
  changed_when: false
  become: true
  when: udev_rules.changed
  tags: [optimizations]

- name: Trigger udev rules now (without reboot)
  ansible.builtin.command:
    argv: ["udevadm", "trigger"]
  changed_when: false
  become: true
  when: udev_rules.changed
  tags: [optimizations]

- name: Add noatime to root filesystem in fstab (safest persistent way)
  ansible.builtin.replace:
    path: /etc/fstab
    regexp: '(\s+/+\s+{{ ansible_mounts | selectattr("mount","equalto","/") | map(attribute="fstype") | first }}\s+.*\s)(defaults)(,)(?!noatime)'
    replace: '\1\2,noatime\3'
  become: true
  register: fstab_noatime
  tags: [optimizations]

- name: Remount root with noatime if fstab changed
  ansible.builtin.mount:
    path: /
    state: remounted
  become: true
  when: fstab_noatime.changed
  tags: [optimizations]
